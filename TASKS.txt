1. Client side javascript
   - code for making API codes
   - code for writing things prettily
2. Server side code
   - reactive tasks (respond to API calls)
   - background tasks (check wallets, check margins, transfer money at each settlement, etc)


A - database schema
A - handling position changes after match()
A - background task to handle daily settlements and expirations
- API call to list pending orders for a given user and market
- API call to create an account
- API call to get list of positions (including balance)

- signing messages with private key in browser
- checking signatures in websocket
- making websocket use SSL all the time always

- logging all trades
- API call to receive list of previous trades to build pretty graphs
- javascript code to build pretty graphs based on list of trades

- API call to get an address to deposit money
- API call to withdraw money
- background daemon to check if bitcoins have been received and if so credit them to the right account

- logging all orders to be able to replay in case of crash
- tightening of network code to handle matching engine crashes

- background task to send margin call emails
- background task to automatically dump positions for low margin accounts [can be done manually at first]
- background task to automatically send a reminder that some markets are about to expire (to admins)

---------------------------------------------


createAccount(nickname,  passwordhash, email, bitmessage) => creates an account for a user
getBTCBalance() ( == getPosition('BTC') ) => returns an integer, the number of BTC in satoshis
getBTCMargin() => returns an integer, the amount of BTC taken up by the margin
getPositions()  => return a dictionary of all positions e.g. {'BTC':304,'TWITTER':3404}
getPosition(contract) => an integer, the position in this specific contract
withdrawToAddress(bitcoin_address) => transaction_id
getDepositAddress() => a bitcoin address to deposit coins, it is created on the fly and tied to the account in the db
placeOrder(contract, amount, price, side) => returns an error code or the order_id if successful
cancelOrder(order_id) => returns an error code or a success code... if the order_id are picked randomly and are 128 bits and remain secret, no need to check if the user owns the order
getPendingOrders() => returns a list of pending orders for a user
getPendingOrdersByContract(ticker) => same, by ticker
getHistoricalOrders(since_date) => returns a list of all orders placed since
getListOfTickers()

question_marks?
getOrderBook(ticker): stream of the top levels of the order book
getTape(ticker): stream of trades for a certain ticker





